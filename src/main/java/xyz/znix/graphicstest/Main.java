/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package xyz.znix.graphicstest;

import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import jopenvr.JOpenVRLibrary.EColorSpace;
import jopenvr.JOpenVRLibrary.ETextureType;
import jopenvr.Texture_t;
import org.lwjgl.LWJGLException;
import org.lwjgl.Sys;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;
import org.lwjgl.opengl.GL13;
import org.lwjgl.util.glu.GLU;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL30.*;
import static org.lwjgl.opengl.GL32.glFramebufferTexture;
import static org.lwjgl.opengl.GL42.glTexStorage2D;

public class Main {
    public static final boolean USE_VR = false;

    // The window handle
    private long window;

    private OpenVR vr;
    private EyeBuffer[] eyes;

    long frameCount;

    public void run() {
        System.out.println("Hello LWJGL " + Sys.getVersion() + "!");

        init();
        loop();
    }

    private void init() {
        try {
            Display.setTitle("Hello World");
            DisplayMode mode = null;
            for (DisplayMode m : Display.getAvailableDisplayModes()) {
                System.out.println("Mode: " + m);
                if (m.getWidth() == 480)
                    mode = m;
            }
            if (mode != null) {
                Display.setDisplayMode(mode);
            }
            Display.setFullscreen(false);
            Display.setResizable(true);
            Display.create();
        } catch (LWJGLException e) {
            throw new RuntimeException(e);
        }

        // Setup VR
        if (USE_VR)
            vr = new OpenVR();

        eyes = new EyeBuffer[]{new EyeBuffer(), new EyeBuffer()};
    }

    private void loop() {
        int i = 0;

        // Run the rendering loop until the user has attempted to close
        // the window or has pressed the ESCAPE key.
        while (!Display.isCloseRequested()) {
            if (USE_VR)
                vr.compositor.WaitGetPoses.apply(null, 0, null, 0);

            // Desktop view
            glBindFramebuffer(GL_FRAMEBUFFER, 0);
            drawScene();

            for (EyeBuffer eye : eyes) {
                glBindFramebuffer(GL_FRAMEBUFFER, eye.frameBuffer);
                drawScene();

                glBindFramebuffer(GL_FRAMEBUFFER, eye.frameBuffer);
                drawScene();
            }

            if (!USE_VR) {
                // No need to sync if the VR compositor is doing that for us
                // Display.sync(60);
                try {
                    //noinspection BusyWait
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            } else {
                // Submit the textures for both eyes to the runtime
                for (int eye = 0; eye < 2; eye++) {
                    Texture_t tex = new Texture_t();
                    tex.eType = ETextureType.ETextureType_TextureType_OpenGL;
                    tex.eColorSpace = EColorSpace.EColorSpace_ColorSpace_Gamma;
                    tex.handle = new Pointer(eyes[eye].tex);
                    tex.write();

                    vr.compositor.Submit.apply(eye, tex, null, 0);

                    // Not exactly my favourite way of handling this, but JNA doesn't let us dispose the memory ourselves
                    // Instead, it'll automatically do it when it's Java representation is GC'd
                }
            }

            Display.update();

            frameCount++;
        }

        Display.destroy();
    }

    private void drawScene() {
        // Set the clear colour
        glClearColor(0, 0, 0.0f, 1.0f);

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer

        glEnable(GL_DEPTH_TEST);
        glDisable(GL_CULL_FACE);

        glLoadIdentity();
        // TODO vary for VR viewports
        GLU.gluPerspective(90, 1.0f * Display.getWidth() / Display.getHeight(), 0.05f, 100);
        // GLU.gluOrtho2D(-1, -1, 1, 1);

        glTranslatef(0, 0, -2);

        // Spin over time
        glRotatef(frameCount * 0.8f, 0, 1, 0);
        glRotatef(frameCount * 0.1f, 1, 0, 0);

        // Translate in by half a unit so the cube is centred
        glTranslatef(-0.5f, -0.5f, -0.5f);

        glBegin(GL_QUADS);

        // front
        glColor3f(1, 0, 0);
        glVertex3f(0, 0, 1);
        glVertex3f(1, 0, 1);
        glVertex3f(1, 1, 1);
        glVertex3f(0, 1, 1);
        // back
        glColor3f(0, 1, 0);
        glVertex3f(0, 0, 0);
        glVertex3f(1, 0, 0);
        glVertex3f(1, 1, 0);
        glVertex3f(0, 1, 0);
        // top
        glColor3f(0, 0, 1);
        glVertex3f(0, 1, 0);
        glVertex3f(1, 1, 0);
        glVertex3f(1, 1, 1);
        glVertex3f(0, 1, 1);
        // bottom
        glColor3f(1, 0, 1);
        glVertex3f(0, 0, 0);
        glVertex3f(1, 0, 0);
        glVertex3f(1, 0, 1);
        glVertex3f(0, 0, 1);
        // left
        glColor3f(1, 0, 1);
        glVertex3f(0, 0, 0);
        glVertex3f(0, 1, 0);
        glVertex3f(0, 1, 1);
        glVertex3f(0, 0, 1);
        // right
        glColor3f(1, 1, 1);
        glVertex3f(1, 0, 0);
        glVertex3f(1, 1, 0);
        glVertex3f(1, 1, 1);
        glVertex3f(1, 0, 1);

        glEnd();
    }

    public static void main(String[] args) {
        System.out.println("hello");

        Main main = new Main();
        main.run();
    }

    private class EyeBuffer {
        int tex;
        int frameBuffer;

        EyeBuffer() {
            int err = glGetError();
            if (err != 0) {
                throw new RuntimeException("OpenGL pre-failed: " + err);
            }

            // Create the texture
            IntByReference width = new IntByReference();
            IntByReference height = new IntByReference();
            if (USE_VR) {
                vr.system.GetRecommendedRenderTargetSize.apply(width, height);
            } else {
                width.setValue(500);
                height.setValue(600);
            }

            tex = glGenTextures();

            err = glGetError();
            if (err != 0) {
                throw new RuntimeException("OpenGL Failed creating texture: " + err);
            }

            if (tex == 0) {
                throw new RuntimeException("glGenTextures returned 0");
            }

            GL13.glActiveTexture(GL13.GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, tex);
            glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, width.getValue(), height.getValue());

            err = glGetError();
            if (err != 0) {
                throw new RuntimeException("OpenGL Failed setting texture contents: " + err);
            }

            // Create the frame buffer
            frameBuffer = glGenFramebuffers();
            glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer);

            glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, tex, 0);

            // The depth buffer
            int depthRenderBuffer = glGenRenderbuffers();
            glBindRenderbuffer(GL_RENDERBUFFER, depthRenderBuffer);
            glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, 1024, 768);
            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderBuffer);

            // Last error check
            err = glGetError();
            if (err != 0) {
                throw new RuntimeException("OpenGL Failed FB: " + err);
            }
        }
    }
}
